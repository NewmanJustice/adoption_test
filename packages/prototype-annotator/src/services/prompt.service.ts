import fs from 'fs';
import path from 'path';
import { AnnotationRepository } from '../db/repositories/annotations.js';
import { PromptExportRepository } from '../db/repositories/prompts.js';
import { EventRepository } from '../db/repositories/events.js';
import type {
  Annotation,
  ElementAnchor,
  GeneratePromptInput,
  GeneratedPrompt,
  PromptExport,
  ResolvedConfig,
} from '../types/index.js';

const AGENTIC_DEV_TEMPLATE = `# Implementation Prompt

## Context

This document contains feedback and annotations collected from a prototype review session. The annotations describe required changes, observations, and suggestions for improvement.

## Screens in Scope

{{screens_section}}

## Observations

{{observations_section}}

## Required Changes

{{changes_section}}

## Acceptance Criteria

{{acceptance_section}}

## Suggested Tests / Checks

{{tests_section}}

## Assumptions & Out of Scope

- Authentication and authorization are not in scope for this change
- Performance optimization is not required unless explicitly mentioned
- Backwards compatibility should be maintained where possible

---

**Generated:** {{generated_at}}
**Annotations included:** {{annotation_count}}
**Template:** agentic-dev

*Generated by prototype-annotator*
`;

export class PromptService {
  private annotationRepo: AnnotationRepository;
  private promptRepo: PromptExportRepository;
  private eventRepo: EventRepository;
  private config: ResolvedConfig;

  constructor(config: ResolvedConfig) {
    this.annotationRepo = new AnnotationRepository();
    this.promptRepo = new PromptExportRepository();
    this.eventRepo = new EventRepository();
    this.config = config;
  }

  async generate(input: GeneratePromptInput): Promise<GeneratedPrompt> {
    // Get annotations by URLs or specific IDs
    let annotations: Annotation[] = [];

    if (input.annotation_ids && input.annotation_ids.length > 0) {
      annotations = this.annotationRepo.findByIds(input.annotation_ids);
    } else if (input.urls && input.urls.length > 0) {
      for (const url of input.urls) {
        const urlAnnotations = this.annotationRepo.findByUrl(url);
        annotations.push(...urlAnnotations);
      }
    } else {
      annotations = this.annotationRepo.findAll();
    }

    // Generate markdown from template
    const markdown = this.generateMarkdown(annotations);

    return {
      markdown,
      annotations,
      enhanced: false,
    };
  }

  async confirm(input: GeneratePromptInput & { markdown?: string }): Promise<PromptExport> {
    // If markdown is provided, use it directly (user may have edited it)
    let markdown = input.markdown;
    let annotations: Annotation[] = [];

    if (!markdown) {
      const generated = await this.generate(input);
      markdown = generated.markdown;
      annotations = generated.annotations;
    } else {
      // Get annotations for metadata
      if (input.annotation_ids && input.annotation_ids.length > 0) {
        annotations = this.annotationRepo.findByIds(input.annotation_ids);
      } else if (input.urls && input.urls.length > 0) {
        for (const url of input.urls) {
          const urlAnnotations = this.annotationRepo.findByUrl(url);
          annotations.push(...urlAnnotations);
        }
      }
    }

    // Ensure export directory exists
    if (!fs.existsSync(this.config.exportDir)) {
      fs.mkdirSync(this.config.exportDir, { recursive: true });
    }

    // Generate filenames with proper format: YYYY-MM-DD__HHmm__<slug>.md
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
    const timeStr = now.toISOString().slice(11, 16).replace(':', ''); // HHmm
    const slug = this.generateSlug(annotations);
    const baseFilename = `${dateStr}__${timeStr}__${slug}`;
    const mdPath = path.join(this.config.exportDir, `${baseFilename}.md`);
    const jsonPath = path.join(this.config.exportDir, `${baseFilename}.json`);

    // Write markdown file
    fs.writeFileSync(mdPath, markdown, 'utf-8');

    // Write JSON file with metadata
    const jsonContent = {
      generated_at: now.toISOString(),
      actor: input.actor,
      urls: input.urls || [...new Set(annotations.map(a => a.url_full))],
      annotation_ids: annotations.map((a) => a.id),
      template_id: input.template_id || 'agentic-dev',
      prompt_markdown: markdown,
      annotations: annotations,
    };
    fs.writeFileSync(jsonPath, JSON.stringify(jsonContent, null, 2), 'utf-8');

    // Save to database
    const promptExport = this.promptRepo.create({
      actor: input.actor,
      url_scope: input.urls || [...new Set(annotations.map(a => a.url_full))],
      annotation_ids: annotations.map((a) => a.id),
      template_id: input.template_id || 'agentic-dev',
      prompt_markdown: markdown,
      saved_path_md: mdPath,
      saved_path_json: jsonPath,
    });

    // Log export event
    this.eventRepo.create({
      annotation_id: null,
      event_type: 'EXPORT_PROMPT',
      actor: input.actor,
      meta: {
        export_id: promptExport.id,
        annotation_count: annotations.length,
        paths: { md: mdPath, json: jsonPath },
      },
    });

    return promptExport;
  }

  // Keep export as alias for confirm for backwards compatibility
  async export(input: GeneratePromptInput): Promise<PromptExport> {
    return this.confirm(input);
  }

  findExportById(id: string): PromptExport | null {
    return this.promptRepo.findById(id);
  }

  findAllExports(limit = 50, offset = 0): PromptExport[] {
    return this.promptRepo.findAll(limit, offset);
  }

  private generateSlug(annotations: Annotation[]): string {
    if (annotations.length === 0) return 'empty';

    // Use first annotation title to generate slug
    const title = annotations[0].title;
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .slice(0, 30) || 'annotations';
  }

  private formatElementLocation(annotation: Annotation): string {
    if (annotation.anchor_type === 'element') {
      const anchor = annotation.anchor_payload as ElementAnchor;
      const parts: string[] = [];

      if (anchor.selector) {
        parts.push(`Selector: \`${anchor.selector}\``);
      }
      if (anchor.textContent) {
        // Truncate long text content
        const text = anchor.textContent.length > 100
          ? anchor.textContent.slice(0, 100) + '...'
          : anchor.textContent;
        parts.push(`Text: "${text}"`);
      }

      return parts.join(' | ');
    } else {
      // Rectangle selection - just note it's a region
      return 'Region selection (coordinates captured)';
    }
  }

  private generateMarkdown(annotations: Annotation[]): string {
    const now = new Date().toISOString();

    // Group annotations by URL
    const byUrl = new Map<string, Annotation[]>();
    for (const annotation of annotations) {
      const url = annotation.url_full;
      if (!byUrl.has(url)) {
        byUrl.set(url, []);
      }
      byUrl.get(url)!.push(annotation);
    }

    // Generate screens section
    const screensSection = Array.from(byUrl.keys())
      .map(url => `- ${url}`)
      .join('\n') || '- No screens specified';

    // Generate observations section (grouped by screen)
    let observationsSection = '';
    for (const [url, urlAnnotations] of byUrl) {
      observationsSection += `### ${new URL(url).pathname}\n\n`;
      for (const a of urlAnnotations) {
        observationsSection += `- **${a.title}**\n`;
        observationsSection += `  - Element: ${this.formatElementLocation(a)}\n`;
        if (a.body) {
          observationsSection += `  - Note: ${a.body}\n`;
        }
        observationsSection += '\n';
      }
    }
    observationsSection = observationsSection.trim() || 'No observations recorded.';

    // Generate required changes section
    let changesSection = '';
    let changeNum = 1;
    for (const annotation of annotations) {
      changesSection += `${changeNum}. **${annotation.title}**\n`;
      if (annotation.body) {
        changesSection += `   - ${annotation.body}\n`;
      }
      changesSection += `   - Element: ${this.formatElementLocation(annotation)}\n`;
      changesSection += `   - Page: ${annotation.url_canonical}\n\n`;
      changeNum++;
    }
    changesSection = changesSection.trim() || 'No changes specified.';

    // Generate acceptance criteria
    let acceptanceSection = '';
    for (const annotation of annotations) {
      acceptanceSection += `- [ ] ${annotation.title} has been implemented\n`;
    }
    acceptanceSection = acceptanceSection.trim() || '- [ ] All changes have been reviewed and approved';

    // Generate tests section
    let testsSection = '';
    for (const annotation of annotations) {
      testsSection += `- [ ] Verify: ${annotation.title}\n`;
    }
    testsSection += '- [ ] Visual regression test passes\n';
    testsSection += '- [ ] No console errors in browser\n';
    testsSection = testsSection.trim();

    // Replace template placeholders
    let output = AGENTIC_DEV_TEMPLATE;
    output = output.replace('{{screens_section}}', screensSection);
    output = output.replace('{{observations_section}}', observationsSection);
    output = output.replace('{{changes_section}}', changesSection);
    output = output.replace('{{acceptance_section}}', acceptanceSection);
    output = output.replace('{{tests_section}}', testsSection);
    output = output.replace('{{generated_at}}', now);
    output = output.replace('{{annotation_count}}', String(annotations.length));

    return output;
  }
}
